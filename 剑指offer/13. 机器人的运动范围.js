/*
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
示例 1：
输入：m = 3, n = 3, k = 2
输出：3
示例 2：
输入：m = 3, n = 1, k = 0
输出：1
提示：
1 <= n,m <= 100
0 <= k <= 20
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
题解:题目还是有点小迷惑性的，开始以为可以直接通过坐标来算的，但仔细想想不行
举个🌰...
   
        [9, 10]
[10, 9] [10,10] [10,11]
        [11,10]
以[10,10]为例，假设k=2，就算[10,10]符合条件，但由于[10,10]四周都大于2，所以机器人其实无法到达[10,10]
而且会出现另一种情况，就是右边或者下边的k[i,j]可能是比自己小的
所以，老老实实DFS吧......

起始点在[0,0]，判断当前点能不能到达，能的话就移动到周围到点，不能的话就直接返回
因为一开始在左上角，所以，其实我们只需要往右 或者 下 移动就好，不需要走回头路
就算只往右或者下，有些点会重复走，所以要判断一下当前点有没有走过，如果走过，则直接返回就好
 */
let count = 0,map={}
var movingCount = function(m, n, k) {
    map = {}
    count = 0
    m-=1
    n-=1
move(0,0,m,n,k)
   return count
};

function move(i,j,m,n,k){
    let key = `key_${i}_${j}`
    if(map[key]) return 
    if(canMove(i,j,m,n,k)){
        count ++
        map[key] = 1
        move(i+1,j,m,n,k)
        move(i,j+1,m,n,k)
    }
    return 
}
function canMove(i,j,m,n,k){
  if(i<0 || i>m || j<0 || j>n) return false;
  return  (parseInt(i /10) +(i % 10) +parseInt(j / 10) +(j % 10)) <= k
}

console.log(movingCount(3,2,17))